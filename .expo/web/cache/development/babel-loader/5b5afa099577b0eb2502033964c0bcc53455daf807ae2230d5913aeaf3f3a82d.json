{"ast":null,"code":"import { API_ENDPOINTS } from './apiConfig';\nclass LocationService {\n  constructor() {\n    this.isTracking = false;\n    this.locationUpdateInterval = null;\n    this.onLocationUpdateCallback = null;\n    this.baseLocation = {\n      latitude: 19.0760,\n      longitude: 72.8777,\n      accuracy: 15,\n      altitude: 14,\n      heading: 0,\n      speed: 0,\n      timestamp: new Date().getTime()\n    };\n    this.trackingOptions = {\n      timeInterval: 5000,\n      distanceInterval: 10\n    };\n  }\n  async requestPermissions() {\n    try {\n      console.log('Mock: Location permissions requested and granted');\n      return {\n        foregroundStatus: 'granted',\n        backgroundStatus: 'granted'\n      };\n    } catch (error) {\n      console.error('Error in mock permission request:', error);\n      throw error;\n    }\n  }\n  async startLocationTracking(options = {}) {\n    try {\n      await this.requestPermissions();\n      const trackingConfig = Object.assign({}, this.trackingOptions, options);\n      if (this.isTracking) {\n        await this.stopLocationTracking();\n      }\n      const updateInterval = trackingConfig.timeInterval || 5000;\n      this.locationUpdateInterval = setInterval(() => {\n        this.simulateLocationUpdate();\n      }, updateInterval);\n      this.isTracking = true;\n      return {\n        remove: () => this.stopLocationTracking()\n      };\n    } catch (error) {\n      console.error('Error starting mock location tracking:', error);\n      throw error;\n    }\n  }\n  async startBackgroundLocationTracking(options = {}) {\n    try {\n      await this.startLocationTracking(options);\n      console.log('Mock: Background location tracking started');\n      return true;\n    } catch (error) {\n      console.error('Error starting mock background location:', error);\n      throw error;\n    }\n  }\n  simulateLocationUpdate() {\n    try {\n      const jitter = 0.0002;\n      const locationData = {\n        latitude: this.baseLocation.latitude + (Math.random() - 0.5) * jitter,\n        longitude: this.baseLocation.longitude + (Math.random() - 0.5) * jitter,\n        accuracy: this.baseLocation.accuracy + (Math.random() - 0.5) * 5,\n        altitude: this.baseLocation.altitude,\n        heading: Math.random() * 360,\n        speed: Math.random() * 3,\n        timestamp: new Date().getTime()\n      };\n      this.baseLocation = locationData;\n      this.sendLocationToBackend(locationData).catch(error => console.error('Error sending mock location to backend:', error));\n      if (this.onLocationUpdateCallback) {\n        this.onLocationUpdateCallback(locationData);\n      }\n      return locationData;\n    } catch (error) {\n      console.error('Error simulating location update:', error);\n    }\n  }\n  async stopLocationTracking() {\n    try {\n      if (this.locationUpdateInterval) {\n        clearInterval(this.locationUpdateInterval);\n        this.locationUpdateInterval = null;\n      }\n      this.isTracking = false;\n      console.log('Mock: Location tracking stopped');\n      return true;\n    } catch (error) {\n      console.error('Error stopping mock location tracking:', error);\n      throw error;\n    }\n  }\n  async getCurrentLocation() {\n    try {\n      await new Promise(resolve => setTimeout(resolve, 500));\n      return Object.assign({}, this.baseLocation, {\n        timestamp: new Date().getTime()\n      });\n    } catch (error) {\n      console.error('Error getting current mock location:', error);\n      throw error;\n    }\n  }\n  async sendLocationToBackend(locationData) {\n    try {\n      const payload = Object.assign({}, locationData, {\n        deviceId: await this.getDeviceId(),\n        appState: 'foreground'\n      });\n      console.log('Mock: Sending location to backend:', payload);\n      return {\n        success: true,\n        message: 'Location update received'\n      };\n    } catch (error) {\n      console.error('Error in mock location send:', error);\n      this.storeFailedUpdate(locationData);\n      throw error;\n    }\n  }\n  async startEmergencyLocationTracking() {\n    try {\n      return await this.startBackgroundLocationTracking({\n        timeInterval: 3000,\n        distanceInterval: 5\n      });\n    } catch (error) {\n      console.error('Error starting mock emergency tracking:', error);\n      throw error;\n    }\n  }\n  async getDeviceId() {\n    return 'unique-device-id';\n  }\n  onLocationUpdate(callback) {\n    this.onLocationUpdateCallback = callback;\n  }\n  storeFailedUpdate(locationData) {\n    console.log('Storing failed location update for later retry:', locationData);\n  }\n  async retryFailedUpdates() {\n    console.log('Retrying failed location updates');\n  }\n  async getLocationTrackingStatus() {\n    try {\n      return {\n        isTracking: this.isTracking,\n        lastUpdated: new Date().toISOString()\n      };\n    } catch (error) {\n      console.error('Error getting location tracking status:', error);\n      throw error;\n    }\n  }\n}\nconst locationService = new LocationService();\nexport default locationService;","map":{"version":3,"names":["API_ENDPOINTS","LocationService","constructor","isTracking","locationUpdateInterval","onLocationUpdateCallback","baseLocation","latitude","longitude","accuracy","altitude","heading","speed","timestamp","Date","getTime","trackingOptions","timeInterval","distanceInterval","requestPermissions","console","log","foregroundStatus","backgroundStatus","error","startLocationTracking","options","trackingConfig","Object","assign","stopLocationTracking","updateInterval","setInterval","simulateLocationUpdate","remove","startBackgroundLocationTracking","jitter","locationData","Math","random","sendLocationToBackend","catch","clearInterval","getCurrentLocation","Promise","resolve","setTimeout","payload","deviceId","getDeviceId","appState","success","message","storeFailedUpdate","startEmergencyLocationTracking","onLocationUpdate","callback","retryFailedUpdates","getLocationTrackingStatus","lastUpdated","toISOString","locationService"],"sources":["C:/Users/PC/OneDrive/latest/SafeMitraLatest/services/locationService.js"],"sourcesContent":["// Mock implementation of location service that simulates location updates\r\n// This implementation doesn't require expo-location or other external dependencies\r\nimport { API_ENDPOINTS } from './apiConfig';\r\n\r\nclass LocationService {\r\n  constructor() {\r\n    this.isTracking = false;\r\n    this.locationUpdateInterval = null;\r\n    this.onLocationUpdateCallback = null;\r\n    this.baseLocation = {\r\n      latitude: 19.0760, // Mumbai coordinates as starting point\r\n      longitude: 72.8777,\r\n      accuracy: 15,\r\n      altitude: 14,\r\n      heading: 0,\r\n      speed: 0,\r\n      timestamp: new Date().getTime()\r\n    };\r\n    // Tracking options to simulate real location service config\r\n    this.trackingOptions = {\r\n      timeInterval: 5000, // Update every 5 seconds by default\r\n      distanceInterval: 10 // Update if moved by 10 meters\r\n    };\r\n  }\r\n\r\n  // Simulate requesting location permissions\r\n  async requestPermissions() {\r\n    try {\r\n      // In a mock implementation we'll just pretend permissions are granted\r\n      console.log('Mock: Location permissions requested and granted');\r\n      return { foregroundStatus: 'granted', backgroundStatus: 'granted' };\r\n    } catch (error) {\r\n      console.error('Error in mock permission request:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Start simulated location tracking\r\n  async startLocationTracking(options = {}) {\r\n    try {\r\n      // Simulate requesting permissions\r\n      await this.requestPermissions();\r\n      \r\n      // Configure tracking options\r\n      const trackingConfig = {\r\n        ...this.trackingOptions,\r\n        ...options,\r\n      };\r\n\r\n      // Stop any existing tracking\r\n      if (this.isTracking) {\r\n        await this.stopLocationTracking();\r\n      }\r\n\r\n      // Start simulated location updates at the specified interval\r\n      const updateInterval = trackingConfig.timeInterval || 5000;\r\n      this.locationUpdateInterval = setInterval(() => {\r\n        this.simulateLocationUpdate();\r\n      }, updateInterval);\r\n\r\n      // Set tracking flag\r\n      this.isTracking = true;\r\n      \r\n      return { remove: () => this.stopLocationTracking() };\r\n    } catch (error) {\r\n      console.error('Error starting mock location tracking:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Start simulated background location tracking (for emergency situations)\r\n  async startBackgroundLocationTracking(options = {}) {\r\n    try {\r\n      // This is just a wrapper around startLocationTracking in our mock version\r\n      // In a real implementation, this would use background location services\r\n      await this.startLocationTracking(options);\r\n      console.log('Mock: Background location tracking started');\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error starting mock background location:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Simulate a location update\r\n  simulateLocationUpdate() {\r\n    try {\r\n      // Create small random changes to simulate movement\r\n      const jitter = 0.0002; // Small movement (about 20 meters)\r\n      const locationData = {\r\n        latitude: this.baseLocation.latitude + (Math.random() - 0.5) * jitter,\r\n        longitude: this.baseLocation.longitude + (Math.random() - 0.5) * jitter,\r\n        accuracy: this.baseLocation.accuracy + (Math.random() - 0.5) * 5,\r\n        altitude: this.baseLocation.altitude,\r\n        heading: Math.random() * 360, // Random heading between 0-360 degrees\r\n        speed: Math.random() * 3, // Random speed 0-3 m/s (walking pace)\r\n        timestamp: new Date().getTime(),\r\n      };\r\n      \r\n      // Update the base location for next time to simulate continuous movement\r\n      this.baseLocation = locationData;\r\n\r\n      // Simulate sending location to backend\r\n      this.sendLocationToBackend(locationData)\r\n        .catch(error => console.error('Error sending mock location to backend:', error));\r\n      \r\n      // Call the update callback if registered\r\n      if (this.onLocationUpdateCallback) {\r\n        this.onLocationUpdateCallback(locationData);\r\n      }\r\n      \r\n      return locationData;\r\n    } catch (error) {\r\n      console.error('Error simulating location update:', error);\r\n    }\r\n  }\r\n\r\n  // Stop simulated tracking\r\n  async stopLocationTracking() {\r\n    try {\r\n      // Clear the update interval\r\n      if (this.locationUpdateInterval) {\r\n        clearInterval(this.locationUpdateInterval);\r\n        this.locationUpdateInterval = null;\r\n      }\r\n      \r\n      this.isTracking = false;\r\n      console.log('Mock: Location tracking stopped');\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error stopping mock location tracking:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get current simulated location\r\n  async getCurrentLocation() {\r\n    try {\r\n      // Simulate a small delay as would happen with a real GPS request\r\n      await new Promise(resolve => setTimeout(resolve, 500));\r\n      \r\n      return { ...this.baseLocation, timestamp: new Date().getTime() };\r\n    } catch (error) {\r\n      console.error('Error getting current mock location:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Simulate sending location data to backend\r\n  async sendLocationToBackend(locationData) {\r\n    try {\r\n      // Add any additional metadata needed for the backend\r\n      const payload = {\r\n        ...locationData,\r\n        deviceId: await this.getDeviceId(),\r\n        appState: 'foreground',\r\n      };\r\n      \r\n      // In a mock version, we'll just log what would be sent\r\n      console.log('Mock: Sending location to backend:', payload);\r\n      \r\n      // Simulate a successful API response\r\n      return { success: true, message: 'Location update received' };\r\n    } catch (error) {\r\n      console.error('Error in mock location send:', error);\r\n      // Store failed updates for later retry\r\n      this.storeFailedUpdate(locationData);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Simulate emergency location tracking with more frequent updates\r\n  async startEmergencyLocationTracking() {\r\n    try {\r\n      // When in emergency, update more frequently\r\n      return await this.startBackgroundLocationTracking({\r\n        timeInterval: 3000, // Update every 3 seconds\r\n        distanceInterval: 5,  // Update if moved by 5 meters\r\n      });\r\n    } catch (error) {\r\n      console.error('Error starting mock emergency tracking:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get a unique device ID for tracking purposes\r\n  async getDeviceId() {\r\n    // Implementation depends on your requirements\r\n    // Could use Expo Device.getDeviceIdAsync() or some stored UUID\r\n    return 'unique-device-id'; // Placeholder\r\n  }\r\n\r\n  // Register location update callback\r\n  onLocationUpdate(callback) {\r\n    this.onLocationUpdateCallback = callback;\r\n  }\r\n\r\n  // Store failed update for later retry\r\n  storeFailedUpdate(locationData) {\r\n    // Implement storage logic using AsyncStorage or similar\r\n    console.log('Storing failed location update for later retry:', locationData);\r\n  }\r\n\r\n  // Retry sending stored failed updates\r\n  async retryFailedUpdates() {\r\n    // Implement retry logic\r\n    console.log('Retrying failed location updates');\r\n  }\r\n\r\n  // Get location tracking status\r\n  async getLocationTrackingStatus() {\r\n    try {\r\n      // This could be an API call to get the status from backend\r\n      // or just return the local tracking status\r\n      return {\r\n        isTracking: this.isTracking,\r\n        lastUpdated: new Date().toISOString(),\r\n      };\r\n    } catch (error) {\r\n      console.error('Error getting location tracking status:', error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\n// Create and export a singleton instance\r\nconst locationService = new LocationService();\r\nexport default locationService;\r\n\r\n// No background task registration needed for mock implementation\r\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}