{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\PC\\\\OneDrive\\\\latest\\\\SafeMitraLatest\\\\components\\\\AudioRecorder.js\";\nimport React, { useState, useEffect, useRef } from 'react';\nimport View from \"react-native-web/dist/exports/View\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport AppState from \"react-native-web/dist/exports/AppState\";\nimport { ToastAndroid } from \"react-native-web/dist/index\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport { Audio } from 'expo-av';\nimport { sendAudioToBackend } from '../services/audioService';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst RECORDING_DURATION_MS = 15 * 1000;\nconst MAX_RETRY_ATTEMPTS = 3;\nconst AudioRecorder = () => {\n  const [recording, setRecording] = useState(null);\n  const [isRecording, setIsRecording] = useState(false);\n  const [isUploading, setIsUploading] = useState(false);\n  const [status, setStatus] = useState('initializing');\n  const appState = useRef(AppState.currentState);\n  const uploadAttempts = useRef(0);\n  useEffect(() => {\n    const subscription = AppState.addEventListener('change', nextAppState => {\n      if (appState.current === 'background' && nextAppState === 'active') {\n        if (!isRecording && !isUploading) {\n          startRecording();\n        }\n      }\n      appState.current = nextAppState;\n    });\n    return () => {\n      subscription.remove();\n    };\n  }, [isRecording, isUploading]);\n  useEffect(() => {\n    requestPermissions();\n    return () => {\n      if (recording) {\n        recording.stopAndUnloadAsync().catch(error => {\n          console.error('Error stopping recording on unmount:', error);\n        });\n      }\n    };\n  }, []);\n  const showNotification = message => {\n    if (Platform.OS === 'android') {\n      ToastAndroid.show(message, ToastAndroid.SHORT);\n    } else {\n      console.log(`[${new Date().toLocaleTimeString()}] ${message}`);\n    }\n  };\n  const requestPermissions = async () => {\n    try {\n      const {\n        status\n      } = await Audio.requestPermissionsAsync();\n      if (status === 'granted') {\n        await Audio.setAudioModeAsync({\n          allowsRecordingIOS: true,\n          playsInSilentModeIOS: true,\n          shouldDuckAndroid: true,\n          playThroughEarpieceAndroid: false\n        });\n        startRecording();\n      } else {\n        setStatus('error');\n        showNotification('Microphone permission denied');\n      }\n    } catch (error) {\n      console.error('Failed to get permissions:', error);\n      setStatus('error');\n      setTimeout(requestPermissions, 3000);\n    }\n  };\n  const startRecording = async () => {\n    try {\n      if (isRecording) {\n        console.log('Already recording, skipping startRecording call');\n        return;\n      }\n      setStatus('recording');\n      setIsRecording(true);\n      const {\n        recording\n      } = await Audio.Recording.createAsync({\n        android: {\n          extension: '.m4a',\n          outputFormat: Audio.AndroidOutputFormat.MPEG_4,\n          audioEncoder: Audio.AndroidAudioEncoder.AAC,\n          sampleRate: 44100,\n          numberOfChannels: 2,\n          bitRate: 128000\n        },\n        ios: {\n          extension: '.m4a',\n          outputFormat: Audio.IOSOutputFormat.MPEG4AAC,\n          audioQuality: Audio.IOSAudioQuality.HIGH,\n          sampleRate: 44100,\n          numberOfChannels: 2,\n          bitRate: 128000,\n          linearPCMBitDepth: 16,\n          linearPCMIsBigEndian: false,\n          linearPCMIsFloat: false\n        },\n        web: {\n          mimeType: 'audio/mp4',\n          bitsPerSecond: 128000\n        }\n      });\n      setRecording(recording);\n      setTimeout(() => {\n        if (recording) {\n          stopRecording(recording).catch(error => {\n            console.error('Error in stopRecording from timeout:', error);\n            setIsRecording(false);\n            startRecording();\n          });\n        }\n      }, RECORDING_DURATION_MS);\n    } catch (error) {\n      console.error('Failed to start recording:', error);\n      setStatus('error');\n      setIsRecording(false);\n      setTimeout(startRecording, 2000);\n    }\n  };\n  const stopRecording = async rec => {\n    if (!rec) {\n      console.error('No recording to stop');\n      setIsRecording(false);\n      startRecording();\n      return;\n    }\n    try {\n      setIsRecording(false);\n      setIsUploading(true);\n      setStatus('uploading');\n      await rec.stopAndUnloadAsync();\n      const uri = rec.getURI();\n      if (!uri) {\n        throw new Error('Recording URI is null');\n      }\n      console.log(`Attempting to upload recording: ${uri}`);\n      const result = await sendAudioToBackend(uri);\n      showNotification(`Audio uploaded: ${result.filename}`);\n      uploadAttempts.current = 0;\n      setIsUploading(false);\n      startRecording();\n    } catch (error) {\n      console.error('Error handling recording:', error);\n      setIsUploading(false);\n      setStatus('error');\n      showNotification(`Upload failed: ${error.message}`);\n      uploadAttempts.current += 1;\n      if (uploadAttempts.current <= MAX_RETRY_ATTEMPTS) {\n        const delay = Math.min(1000 * Math.pow(1.5, uploadAttempts.current), 5000);\n        console.log(`Retrying recording in ${delay}ms (attempt ${uploadAttempts.current}/${MAX_RETRY_ATTEMPTS})`);\n        setTimeout(startRecording, delay);\n      } else {\n        console.log('Max retry attempts reached, continuing with new recording');\n        uploadAttempts.current = 0;\n        startRecording();\n      }\n    }\n  };\n  return _jsxDEV(View, {\n    style: styles.container,\n    pointerEvents: \"none\",\n    children: _jsxDEV(View, {\n      style: styles.indicator,\n      children: _jsxDEV(View, {\n        style: [styles.dot, status === 'recording' ? styles.recordingDot : status === 'uploading' ? styles.uploadingDot : status === 'error' ? styles.errorDot : styles.initDot]\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 198,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 197,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 196,\n    columnNumber: 5\n  }, this);\n};\nconst styles = StyleSheet.create({\n  container: {\n    position: 'absolute',\n    top: 0,\n    right: 0,\n    zIndex: 9999\n  },\n  indicator: {\n    padding: 8,\n    marginTop: 10,\n    marginRight: 10\n  },\n  dot: {\n    width: 8,\n    height: 8,\n    borderRadius: 4\n  },\n  initDot: {\n    backgroundColor: '#888'\n  },\n  recordingDot: {\n    backgroundColor: '#4CAF50'\n  },\n  uploadingDot: {\n    backgroundColor: '#2196F3'\n  },\n  errorDot: {\n    backgroundColor: '#F44336'\n  }\n});\nexport default AudioRecorder;","map":{"version":3,"names":["React","useState","useEffect","useRef","View","StyleSheet","AppState","ToastAndroid","Platform","Audio","sendAudioToBackend","jsxDEV","_jsxDEV","RECORDING_DURATION_MS","MAX_RETRY_ATTEMPTS","AudioRecorder","recording","setRecording","isRecording","setIsRecording","isUploading","setIsUploading","status","setStatus","appState","currentState","uploadAttempts","subscription","addEventListener","nextAppState","current","startRecording","remove","requestPermissions","stopAndUnloadAsync","catch","error","console","showNotification","message","OS","show","SHORT","log","Date","toLocaleTimeString","requestPermissionsAsync","setAudioModeAsync","allowsRecordingIOS","playsInSilentModeIOS","shouldDuckAndroid","playThroughEarpieceAndroid","setTimeout","Recording","createAsync","android","extension","outputFormat","AndroidOutputFormat","MPEG_4","audioEncoder","AndroidAudioEncoder","AAC","sampleRate","numberOfChannels","bitRate","ios","IOSOutputFormat","MPEG4AAC","audioQuality","IOSAudioQuality","HIGH","linearPCMBitDepth","linearPCMIsBigEndian","linearPCMIsFloat","web","mimeType","bitsPerSecond","stopRecording","rec","uri","getURI","Error","result","filename","delay","Math","min","pow","style","styles","container","pointerEvents","children","indicator","dot","recordingDot","uploadingDot","errorDot","initDot","fileName","_jsxFileName","lineNumber","columnNumber","create","position","top","right","zIndex","padding","marginTop","marginRight","width","height","borderRadius","backgroundColor"],"sources":["C:/Users/PC/OneDrive/latest/SafeMitraLatest/components/AudioRecorder.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\r\nimport { View, StyleSheet, AppState, ToastAndroid, Platform } from 'react-native';\r\nimport { Audio } from 'expo-av';\r\nimport { sendAudioToBackend } from '../services/audioService';\r\n\r\n// Shorter recordings for faster SOS response\r\nconst RECORDING_DURATION_MS = 15 * 1000; // 15 seconds\r\nconst MAX_RETRY_ATTEMPTS = 3;\r\n\r\nconst AudioRecorder = () => {\r\n  const [recording, setRecording] = useState(null);\r\n  const [isRecording, setIsRecording] = useState(false);\r\n  const [isUploading, setIsUploading] = useState(false);\r\n  const [status, setStatus] = useState('initializing'); // 'initializing', 'recording', 'uploading', 'error'\r\n  const appState = useRef(AppState.currentState);\r\n  const uploadAttempts = useRef(0);\r\n\r\n  // Handle app state changes (background/foreground)\r\n  useEffect(() => {\r\n    const subscription = AppState.addEventListener('change', nextAppState => {\r\n      if (appState.current === 'background' && nextAppState === 'active') {\r\n        // App came back to foreground, restart recording if needed\r\n        if (!isRecording && !isUploading) {\r\n          startRecording();\r\n        }\r\n      }\r\n      appState.current = nextAppState;\r\n    });\r\n\r\n    return () => {\r\n      subscription.remove();\r\n    };\r\n  }, [isRecording, isUploading]);\r\n\r\n  useEffect(() => {\r\n    requestPermissions();\r\n    return () => {\r\n      if (recording) {\r\n        recording.stopAndUnloadAsync().catch(error => {\r\n          console.error('Error stopping recording on unmount:', error);\r\n        });\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const showNotification = (message) => {\r\n    if (Platform.OS === 'android') {\r\n      ToastAndroid.show(message, ToastAndroid.SHORT);\r\n    } else {\r\n      // Show a console message with timestamp\r\n      console.log(`[${new Date().toLocaleTimeString()}] ${message}`);\r\n    }\r\n  };\r\n\r\n  const requestPermissions = async () => {\r\n    try {\r\n      const { status } = await Audio.requestPermissionsAsync();\r\n      if (status === 'granted') {\r\n        await Audio.setAudioModeAsync({\r\n          allowsRecordingIOS: true,\r\n          playsInSilentModeIOS: true,\r\n          shouldDuckAndroid: true,\r\n          playThroughEarpieceAndroid: false,\r\n        });\r\n        startRecording();\r\n      } else {\r\n        setStatus('error');\r\n        showNotification('Microphone permission denied');\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to get permissions:', error);\r\n      setStatus('error');\r\n      // Retry permissions after a delay\r\n      setTimeout(requestPermissions, 3000);\r\n    }\r\n  };\r\n\r\n  const startRecording = async () => {\r\n    try {\r\n      if (isRecording) {\r\n        console.log('Already recording, skipping startRecording call');\r\n        return;\r\n      }\r\n\r\n      setStatus('recording');\r\n      setIsRecording(true);\r\n      \r\n      // Use specific audio recording settings that are known to work well\r\n      const { recording } = await Audio.Recording.createAsync({\r\n        android: {\r\n          extension: '.m4a',\r\n          outputFormat: Audio.AndroidOutputFormat.MPEG_4,\r\n          audioEncoder: Audio.AndroidAudioEncoder.AAC,\r\n          sampleRate: 44100,\r\n          numberOfChannels: 2,\r\n          bitRate: 128000,\r\n        },\r\n        ios: {\r\n          extension: '.m4a',\r\n          outputFormat: Audio.IOSOutputFormat.MPEG4AAC,\r\n          audioQuality: Audio.IOSAudioQuality.HIGH,\r\n          sampleRate: 44100,\r\n          numberOfChannels: 2,\r\n          bitRate: 128000,\r\n          linearPCMBitDepth: 16,\r\n          linearPCMIsBigEndian: false,\r\n          linearPCMIsFloat: false,\r\n        },\r\n        web: {\r\n          mimeType: 'audio/mp4',\r\n          bitsPerSecond: 128000,\r\n        }\r\n      });\r\n      \r\n      setRecording(recording);\r\n      \r\n      // Set a timeout to stop recording after RECORDING_DURATION_MS\r\n      setTimeout(() => {\r\n        if (recording) {\r\n          stopRecording(recording).catch(error => {\r\n            console.error('Error in stopRecording from timeout:', error);\r\n            setIsRecording(false);\r\n            startRecording(); // Try to restart\r\n          });\r\n        }\r\n      }, RECORDING_DURATION_MS);\r\n      \r\n    } catch (error) {\r\n      console.error('Failed to start recording:', error);\r\n      setStatus('error');\r\n      setIsRecording(false);\r\n      // Try to restart recording after a delay\r\n      setTimeout(startRecording, 2000);\r\n    }\r\n  };\r\n\r\n  const stopRecording = async (rec) => {\r\n    if (!rec) {\r\n      console.error('No recording to stop');\r\n      setIsRecording(false);\r\n      startRecording();\r\n      return;\r\n    }\r\n    \r\n    try {\r\n      setIsRecording(false);\r\n      setIsUploading(true);\r\n      setStatus('uploading');\r\n      \r\n      await rec.stopAndUnloadAsync();\r\n      const uri = rec.getURI();\r\n      \r\n      if (!uri) {\r\n        throw new Error('Recording URI is null');\r\n      }\r\n      \r\n      console.log(`Attempting to upload recording: ${uri}`);\r\n      // Send to backend\r\n      const result = await sendAudioToBackend(uri);\r\n      \r\n      // Show success notification\r\n      showNotification(`Audio uploaded: ${result.filename}`);\r\n      \r\n      // Reset upload attempts on success\r\n      uploadAttempts.current = 0;\r\n      setIsUploading(false);\r\n      \r\n      // Start next recording\r\n      startRecording();\r\n      \r\n    } catch (error) {\r\n      console.error('Error handling recording:', error);\r\n      setIsUploading(false);\r\n      setStatus('error');\r\n      \r\n      // Show error notification\r\n      showNotification(`Upload failed: ${error.message}`);\r\n      \r\n      uploadAttempts.current += 1;\r\n      \r\n      if (uploadAttempts.current <= MAX_RETRY_ATTEMPTS) {\r\n        // Retry with exponential backoff\r\n        const delay = Math.min(1000 * Math.pow(1.5, uploadAttempts.current), 5000);\r\n        console.log(`Retrying recording in ${delay}ms (attempt ${uploadAttempts.current}/${MAX_RETRY_ATTEMPTS})`);\r\n        setTimeout(startRecording, delay);\r\n      } else {\r\n        // After MAX_RETRY_ATTEMPTS, just continue recording without trying to upload\r\n        console.log('Max retry attempts reached, continuing with new recording');\r\n        uploadAttempts.current = 0;\r\n        startRecording();\r\n      }\r\n    }\r\n  };\r\n\r\n  return (\r\n    <View style={styles.container} pointerEvents=\"none\">\r\n      <View style={styles.indicator}>\r\n        <View \r\n          style={[\r\n            styles.dot, \r\n            status === 'recording' ? styles.recordingDot : \r\n            status === 'uploading' ? styles.uploadingDot : \r\n            status === 'error' ? styles.errorDot : styles.initDot\r\n          ]} \r\n        />\r\n      </View>\r\n    </View>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    position: 'absolute',\r\n    top: 0,\r\n    right: 0,\r\n    zIndex: 9999,\r\n  },\r\n  indicator: {\r\n    padding: 8,\r\n    marginTop: 10,\r\n    marginRight: 10,\r\n  },\r\n  dot: {\r\n    width: 8,\r\n    height: 8,\r\n    borderRadius: 4,\r\n  },\r\n  initDot: {\r\n    backgroundColor: '#888',\r\n  },\r\n  recordingDot: {\r\n    backgroundColor: '#4CAF50', // Green\r\n  },\r\n  uploadingDot: {\r\n    backgroundColor: '#2196F3', // Blue\r\n  },\r\n  errorDot: {\r\n    backgroundColor: '#F44336', // Red\r\n  }\r\n});\r\n\r\nexport default AudioRecorder; "],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}