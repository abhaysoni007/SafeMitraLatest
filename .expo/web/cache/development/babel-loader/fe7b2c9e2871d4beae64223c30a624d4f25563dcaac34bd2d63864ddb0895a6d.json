{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nexport default class InternetReachability {\n  constructor(configuration, listener) {\n    _defineProperty(this, \"_configuration\", void 0);\n    _defineProperty(this, \"_listener\", void 0);\n    _defineProperty(this, \"_isInternetReachable\", undefined);\n    _defineProperty(this, \"_currentInternetReachabilityCheckHandler\", null);\n    _defineProperty(this, \"_currentTimeoutHandle\", null);\n    _defineProperty(this, \"_setIsInternetReachable\", isInternetReachable => {\n      if (this._isInternetReachable === isInternetReachable) {\n        return;\n      }\n      this._isInternetReachable = isInternetReachable;\n      this._listener(this._isInternetReachable);\n    });\n    _defineProperty(this, \"_setExpectsConnection\", expectsConnection => {\n      if (this._currentInternetReachabilityCheckHandler !== null) {\n        this._currentInternetReachabilityCheckHandler.cancel();\n        this._currentInternetReachabilityCheckHandler = null;\n      }\n      if (this._currentTimeoutHandle !== null) {\n        clearTimeout(this._currentTimeoutHandle);\n        this._currentTimeoutHandle = null;\n      }\n      if (expectsConnection && this._configuration.reachabilityShouldRun()) {\n        if (!this._isInternetReachable) {\n          this._setIsInternetReachable(null);\n        }\n        this._currentInternetReachabilityCheckHandler = this._checkInternetReachability();\n      } else {\n        this._setIsInternetReachable(false);\n      }\n    });\n    _defineProperty(this, \"_checkInternetReachability\", () => {\n      const controller = new AbortController();\n      const responsePromise = fetch(this._configuration.reachabilityUrl, {\n        headers: this._configuration.reachabilityHeaders,\n        method: this._configuration.reachabilityMethod,\n        cache: 'no-cache',\n        signal: controller.signal\n      });\n      let timeoutHandle;\n      const timeoutPromise = new Promise((_, reject) => {\n        timeoutHandle = setTimeout(() => reject('timedout'), this._configuration.reachabilityRequestTimeout);\n      });\n      let cancel = () => {};\n      const cancelPromise = new Promise((_, reject) => {\n        cancel = () => reject('canceled');\n      });\n      const promise = Promise.race([responsePromise, timeoutPromise, cancelPromise]).then(response => {\n        return this._configuration.reachabilityTest(response);\n      }).then(result => {\n        this._setIsInternetReachable(result);\n        const nextTimeoutInterval = this._isInternetReachable ? this._configuration.reachabilityLongTimeout : this._configuration.reachabilityShortTimeout;\n        this._currentTimeoutHandle = setTimeout(this._checkInternetReachability, nextTimeoutInterval);\n      }).catch(error => {\n        if ('canceled' === error) {\n          controller.abort();\n        } else {\n          if ('timedout' === error) {\n            controller.abort();\n          }\n          this._setIsInternetReachable(false);\n          this._currentTimeoutHandle = setTimeout(this._checkInternetReachability, this._configuration.reachabilityShortTimeout);\n        }\n      }).then(() => {\n        clearTimeout(timeoutHandle);\n      }, error => {\n        clearTimeout(timeoutHandle);\n        throw error;\n      });\n      return {\n        promise,\n        cancel\n      };\n    });\n    _defineProperty(this, \"update\", state => {\n      if (typeof state.isInternetReachable === 'boolean' && this._configuration.useNativeReachability) {\n        this._setIsInternetReachable(state.isInternetReachable);\n      } else {\n        this._setExpectsConnection(state.isConnected);\n      }\n    });\n    _defineProperty(this, \"currentState\", () => {\n      return this._isInternetReachable;\n    });\n    _defineProperty(this, \"tearDown\", () => {\n      if (this._currentInternetReachabilityCheckHandler !== null) {\n        this._currentInternetReachabilityCheckHandler.cancel();\n        this._currentInternetReachabilityCheckHandler = null;\n      }\n      if (this._currentTimeoutHandle !== null) {\n        clearTimeout(this._currentTimeoutHandle);\n        this._currentTimeoutHandle = null;\n      }\n    });\n    this._configuration = configuration;\n    this._listener = listener;\n  }\n}","map":{"version":3,"names":["InternetReachability","constructor","configuration","listener","_defineProperty","undefined","isInternetReachable","_isInternetReachable","_listener","expectsConnection","_currentInternetReachabilityCheckHandler","cancel","_currentTimeoutHandle","clearTimeout","_configuration","reachabilityShouldRun","_setIsInternetReachable","_checkInternetReachability","controller","AbortController","responsePromise","fetch","reachabilityUrl","headers","reachabilityHeaders","method","reachabilityMethod","cache","signal","timeoutHandle","timeoutPromise","Promise","_","reject","setTimeout","reachabilityRequestTimeout","cancelPromise","promise","race","then","response","reachabilityTest","result","nextTimeoutInterval","reachabilityLongTimeout","reachabilityShortTimeout","catch","error","abort","state","useNativeReachability","_setExpectsConnection","isConnected"],"sources":["C:\\Users\\PC\\OneDrive\\latest\\SafeMitraLatest\\node_modules\\@react-native-community\\netinfo\\lib\\module\\internal\\internetReachability.ts"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n */\n\nimport * as PrivateTypes from './privateTypes';\nimport * as Types from './types';\n\ninterface InternetReachabilityCheckHandler {\n  promise: Promise<void>;\n  cancel: () => void;\n}\n\nexport default class InternetReachability {\n  private _configuration: Types.NetInfoConfiguration;\n  private _listener: PrivateTypes.NetInfoInternetReachabilityChangeListener;\n  private _isInternetReachable: boolean | null | undefined = undefined;\n  private _currentInternetReachabilityCheckHandler: InternetReachabilityCheckHandler | null = null;\n  private _currentTimeoutHandle: ReturnType<typeof setTimeout> | null = null;\n\n  constructor(\n    configuration: Types.NetInfoConfiguration,\n    listener: PrivateTypes.NetInfoInternetReachabilityChangeListener,\n  ) {\n    this._configuration = configuration;\n    this._listener = listener;\n  }\n\n  private _setIsInternetReachable = (\n    isInternetReachable: boolean | null,\n  ): void => {\n    if (this._isInternetReachable === isInternetReachable) {\n      return;\n    }\n\n    this._isInternetReachable = isInternetReachable;\n    this._listener(this._isInternetReachable);\n  };\n\n  private _setExpectsConnection = (expectsConnection: boolean | null): void => {\n    // Cancel any pending check\n    if (this._currentInternetReachabilityCheckHandler !== null) {\n      this._currentInternetReachabilityCheckHandler.cancel();\n      this._currentInternetReachabilityCheckHandler = null;\n    }\n    // Cancel any pending timeout\n    if (this._currentTimeoutHandle !== null) {\n      clearTimeout(this._currentTimeoutHandle);\n      this._currentTimeoutHandle = null;\n    }\n\n    if (expectsConnection && this._configuration.reachabilityShouldRun()) {\n      // If we expect a connection, start the process for finding if we have one\n      // Set the state to \"null\" if it was previously false\n      if (!this._isInternetReachable) {\n        this._setIsInternetReachable(null);\n      }\n      // Start a network request to check for internet\n      this._currentInternetReachabilityCheckHandler = this._checkInternetReachability();\n    } else {\n      // If we don't expect a connection or don't run reachability check, just change the state to \"false\"\n      this._setIsInternetReachable(false);\n    }\n  };\n\n  private _checkInternetReachability = (): InternetReachabilityCheckHandler => {\n    const controller = new AbortController();\n\n    const responsePromise = fetch(this._configuration.reachabilityUrl, {\n      headers: this._configuration.reachabilityHeaders,\n      method: this._configuration.reachabilityMethod,\n      cache: 'no-cache',\n      signal: controller.signal,\n    });\n\n    // Create promise that will reject after the request timeout has been reached\n    let timeoutHandle: ReturnType<typeof setTimeout>;\n    const timeoutPromise = new Promise<Response>((_, reject): void => {\n      timeoutHandle = setTimeout(\n        (): void => reject('timedout'),\n        this._configuration.reachabilityRequestTimeout,\n      );\n    });\n\n    // Create promise that makes it possible to cancel a pending request through a reject\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    let cancel: () => void = (): void => {};\n    const cancelPromise = new Promise<Response>((_, reject): void => {\n      cancel = (): void => reject('canceled');\n    });\n\n    const promise = Promise.race([\n      responsePromise,\n      timeoutPromise,\n      cancelPromise,\n    ])\n      .then(\n        (response): Promise<boolean> => {\n          return this._configuration.reachabilityTest(response);\n        },\n      )\n      .then(\n        (result): void => {\n          this._setIsInternetReachable(result);\n          const nextTimeoutInterval = this._isInternetReachable\n            ? this._configuration.reachabilityLongTimeout\n            : this._configuration.reachabilityShortTimeout;\n          this._currentTimeoutHandle = setTimeout(\n            this._checkInternetReachability,\n            nextTimeoutInterval,\n          );\n        },\n      )\n      .catch(\n        (error: Error | 'timedout' | 'canceled'): void => {\n          if ('canceled' === error) {\n            controller.abort();\n          } else {\n            if ('timedout' === error) {\n              controller.abort();\n            }\n            \n            this._setIsInternetReachable(false);\n            this._currentTimeoutHandle = setTimeout(\n              this._checkInternetReachability,\n              this._configuration.reachabilityShortTimeout,\n            );\n          }\n        },\n      )\n      // Clear request timeout and propagate any errors\n      .then(\n        (): void => {\n          clearTimeout(timeoutHandle);\n        },\n        (error: Error): void => {\n          clearTimeout(timeoutHandle);\n          throw error;\n        },\n      );\n\n    return {\n      promise,\n      cancel,\n    };\n  };\n\n  public update = (state: PrivateTypes.NetInfoNativeModuleState): void => {\n    if (\n      typeof state.isInternetReachable === 'boolean' &&\n      this._configuration.useNativeReachability\n    ) {\n      this._setIsInternetReachable(state.isInternetReachable);\n    } else {\n      this._setExpectsConnection(state.isConnected);\n    }\n  };\n\n  public currentState = (): boolean | null | undefined => {\n    return this._isInternetReachable;\n  };\n\n  public tearDown = (): void => {\n    // Cancel any pending check\n    if (this._currentInternetReachabilityCheckHandler !== null) {\n      this._currentInternetReachabilityCheckHandler.cancel();\n      this._currentInternetReachabilityCheckHandler = null;\n    }\n\n    // Cancel any pending timeout\n    if (this._currentTimeoutHandle !== null) {\n      clearTimeout(this._currentTimeoutHandle);\n      this._currentTimeoutHandle = null;\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}